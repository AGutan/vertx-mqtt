/*
 * Copyright 2016 Red Hat Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.vertx.mqtt;

import io.vertx.codegen.annotations.DataObject;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.impl.Arguments;
import io.vertx.core.json.JsonObject;
import io.vertx.core.net.JksOptions;
import io.vertx.core.net.KeyCertOptions;
import io.vertx.core.net.NetClientOptions;
import io.vertx.core.net.PemKeyCertOptions;
import io.vertx.core.net.PemTrustOptions;
import io.vertx.core.net.PfxOptions;
import io.vertx.core.net.TrustOptions;

/**
 * Represents options used by the MQTT client
 */
@DataObject
public class MqttClientOptions extends NetClientOptions {

  private static final int DEFAULT_PORT = 1883;
  private static final int DEFAULT_TSL_PORT = 8883;
  private static final String DEFAULT_HOST = "localhost";
  private static final int DEFAULT_WILL_QOS = 0;
  private static final int DEFAULT_KEEP_ALIVE_TIME_SECONDS = 30;
  private static final boolean DEFAULT_CLEAN_SESSION = true;
  private static final boolean DEFAULT_WILL_FLAG = false;
  private static final boolean DEFAULT_WILL_RETAIN = false;
  public static final int DEFAULT_MAX_MESSAGE_SIZE = -1;

  private int port = DEFAULT_PORT;
  private String host = DEFAULT_HOST;
  private String clientId;
  private String username;
  private String password;
  private String willTopic;
  private String willMessage;
  private boolean cleanSession = DEFAULT_CLEAN_SESSION;
  private boolean willFlag = DEFAULT_WILL_FLAG;
  private int willQoS = DEFAULT_WILL_QOS;
  private boolean willRetain = DEFAULT_WILL_RETAIN;
  private int keepAliveTimeSeconds = DEFAULT_KEEP_ALIVE_TIME_SECONDS;
  private boolean isAutoKeepAlive = true;
  private boolean isAutoGeneratedClientId = true;
  private int maxMessageSize = DEFAULT_MAX_MESSAGE_SIZE;

  /**
   * Default constructor
   */
  public MqttClientOptions() {
    super();
  }

  /**
   * Create an instance of MqttClientOptions from JSON
   *
   * @param json the JSON
   */
  public MqttClientOptions(JsonObject json) {
    super(json);
    //TODO implement this constructor
  }

  /**
   * Copy constructor
   *
   * @param other the options to copy
   */
  public MqttClientOptions(MqttClientOptions other) {
    super(other);
  }

  public MqttClientOptions setPort(int port) {
    this.port = port;
    return this;
  }

  public MqttClientOptions setHost(String host) {
    this.host = host;
    return this;
  }

  public String getHost() {
    return host;
  }

  public int getPort() {
    return port;
  }

  public boolean hasUsername() {
    return username != null;
  }

  public boolean hasPassword() {
    return password != null;
  }

  public boolean isCleanSession() {
    return cleanSession;
  }

  public boolean isWillFlag() {
    return willFlag;
  }

  public boolean isWillRetain() {
    return willRetain;
  }

  public int getWillQoS() {
    return willQoS;
  }

  public int getKeepAliveTimeSeconds() {
    return keepAliveTimeSeconds;
  }

  public String getUsername() {
    return username;
  }

  public String getPassword() {
    return password;
  }

  public String getClientId() {
    return clientId;
  }

  public String getWillTopic() {
    return willTopic;
  }

  public String getWillMessage() {
    return willMessage;
  }

  public MqttClientOptions setClientId(String clientId) {
    this.clientId = clientId;
    return this;
  }

  public MqttClientOptions setUsername(String username) {
    this.username = username;
    return this;
  }

  public MqttClientOptions setPassword(String password) {
    this.password = password;
    return this;
  }

  public MqttClientOptions setWillTopic(String willTopic) {
    this.willTopic = willTopic;
    return this;
  }

  public MqttClientOptions setWillMessage(String willMessage) {
    this.willMessage = willMessage;
    return this;
  }

  public MqttClientOptions setCleanSession(boolean cleanSession) {
    this.cleanSession = cleanSession;
    return this;
  }

  public MqttClientOptions setWillFlag(boolean willFlag) {
    this.willFlag = willFlag;
    return this;
  }

  public MqttClientOptions setWillQoS(int willQoS) {
    this.willQoS = willQoS;
    return this;
  }

  public MqttClientOptions setWillRetain(boolean willRetain) {
    this.willRetain = willRetain;
    return this;
  }

  public MqttClientOptions setKeepAliveTimeSeconds(int keepAliveTimeSeconds) {
    this.keepAliveTimeSeconds = keepAliveTimeSeconds;
    return this;
  }

  /**
   * Set if the MQTT client must handle PINGREQ automatically
   * (default is true)
   *
   * @param isAutoKeepAlive ping request handled automatically
   * @return  current options instance
   */
  public MqttClientOptions setAutoKeepAlive(boolean isAutoKeepAlive) {
    this.isAutoKeepAlive = isAutoKeepAlive;
    return this;
  }

  /**
   * Set if the MQTT client must generate clientId automatically
   * (default is true)
   *
   * @param isAutoGeneratedClientId clientId generated automatically
   * @return  current options instance
   */
  public MqttClientOptions setAutoGeneratedClientId(boolean isAutoGeneratedClientId) {
    this.isAutoGeneratedClientId = isAutoGeneratedClientId;
    return this;
  }

  /**
   * @return if the PINGREQ is handled automatically
   */
  public boolean isAutoKeepAlive() {
    return this.isAutoKeepAlive;
  }

  /**
   * @return if clientId generated automatically
   */
  public boolean isAutoGeneratedClientId() {
    return isAutoGeneratedClientId;
  }

  /**
   * @return max MQTT message size
   */
  public int getMaxMessageSize() {
    return maxMessageSize;
  }

  @Override
  public MqttClientOptions setReceiveBufferSize(int receiveBufferSize) {
    if ((this.maxMessageSize > 0) && (receiveBufferSize > 0)) {
      Arguments.require(receiveBufferSize >= this.maxMessageSize,
        "Receiver buffer size can't be lower than max message size");
    }
    super.setReceiveBufferSize(receiveBufferSize);
    return this;
  }

  /**
   * Set max MQTT message size
   *
   * @param maxMessageSize  max MQTT message size
   * @return  MQTT client options instance
   */
  public MqttClientOptions setMaxMessageSize(int maxMessageSize) {
    Arguments.require(maxMessageSize > 0 || maxMessageSize == DEFAULT_MAX_MESSAGE_SIZE, "maxMessageSize must be > 0");
    if ((maxMessageSize > 0) && (this.getReceiveBufferSize() > 0)) {
      Arguments.require(this.getReceiveBufferSize() >= maxMessageSize,
        "Receiver buffer size can't be lower than max message size");
    }
    this.maxMessageSize = maxMessageSize;
    return this;
  }

  @Override
  public MqttClientOptions setSsl(boolean ssl) {
    super.setSsl(ssl);
    return this;
  }

  @Override
  public MqttClientOptions setTrustStoreOptions(JksOptions options) {
    super.setTrustStoreOptions(options);
    return this;
  }

  @Override
  public MqttClientOptions setTrustAll(boolean trustAll) {
    super.setTrustAll(trustAll);
    return this;
  }

  @Override
  public MqttClientOptions setKeyCertOptions(KeyCertOptions options) {
     super.setKeyCertOptions(options);
     return this;
  }

  @Override
  public MqttClientOptions setKeyStoreOptions(JksOptions options) {
     super.setKeyStoreOptions(options);
     return this;
  }

  @Override
  public MqttClientOptions setPfxKeyCertOptions(PfxOptions options) {
     super.setPfxKeyCertOptions(options);
     return this;
  }

  @Override
  public MqttClientOptions setPemKeyCertOptions(PemKeyCertOptions options) {
     super.setPemKeyCertOptions(options);
     return this;
  }

  @Override
  public MqttClientOptions setTrustOptions(TrustOptions options) {
     super.setTrustOptions(options);
     return this;
  }

  @Override
  public MqttClientOptions setPemTrustOptions(PemTrustOptions options) {
     super.setPemTrustOptions(options);
     return this;
  }

  @Override
  public MqttClientOptions setPfxTrustOptions(PfxOptions options) {
     super.setPfxTrustOptions(options);
     return this;
  }

  @Override
  public MqttClientOptions addEnabledCipherSuite(String suite) {
     super.addEnabledCipherSuite(suite);
     return this;
  }

  @Override
  public MqttClientOptions addEnabledSecureTransportProtocol(String protocol) {
     super.addEnabledSecureTransportProtocol(protocol);
     return this;
  }

  @Override
  public MqttClientOptions addCrlPath(String crlPath) throws NullPointerException {
     super.addCrlPath(crlPath);
     return this;
  }

  @Override
  public MqttClientOptions addCrlValue(Buffer crlValue) throws NullPointerException {
     super.addCrlValue(crlValue);
     return this;
  }

  @Override
  public String toString() {
    return "Options {" +
      "clientId='" + clientId + '\'' +
      ", username='" + username + '\'' +
      ", password='" + password + '\'' +
      ", willTopic='" + willTopic + '\'' +
      ", willMessage='" + willMessage + '\'' +
      ", cleanSession=" + cleanSession +
      ", willFlag=" + willFlag +
      ", willQoS=" + willQoS +
      ", willRetain=" + willRetain +
      ", keepAliveTimeSeconds=" + keepAliveTimeSeconds +
      ", isAutoKeepAlive=" + isAutoKeepAlive +
      '}';
  }
}
