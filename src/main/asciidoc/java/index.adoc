= Vert.x MQTT server

This component provides a server which is able to handle connections, communication and messages exchange with remote [MQTT](http://mqtt.org/) clients. Its API provides a bunch of events related to raw protocol messages received by clients and exposes some functionalities in order to send messages to them.

It's not a fully featured MQTT broker but can be used for building something like that or for protocol translation (MQTT <-> ?).

WARNING: this module has the tech preview status, this means the API can change between versions.

== Using Vert.x MQTT server

As component not yet officially released in the Vert.x stack, to use the Vert.x MQTT server current snapshot version, add the following repository under the _repositories_ section and the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<repository>
  <id>oss.sonatype.org-snapshot</id>
  <url>https://oss.sonatype.org/content/repositories/snapshots</url>
</repository>
----

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-mqtt-server</artifactId>
  <version>3.4.0-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
compile io.vertx:vertx-mqtt-server:3.4.0-SNAPSHOT
----

[source,groovy,subs="+attributes"]
----
maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
----

== Getting Started

=== Handling client connection

This example shows how it's possible to handle the connection request from a remote MQTT client. First, an *_MqttServer_* instance is created and the _endpointHandler_ method is used to specify the handler called when a remote client sends a CONNECT message for connecting to the server itself. The *_MqttEndpoint_* instance, provided as parameter to the handler, brings all main information related to the CONNECT message like client identifier, username/password, "will" information, clean session flag, protocol version and the "keep alive" timeout. Inside that handler, the _endpoint_ instance provides the _writeConnack_ method for replying to the remote client with the corresponding CONNACK message : in this way, the connection is established. Finally, the server is started using the _listen_ method with the default behavior (on localhost and default MQTT port 1883). The same method allows to specify an handler in order to check if the server is started properly or not.

[source,java]
----
MqttServer mqttServer = MqttServer.create(vertx);
mqttServer.endpointHandler(endpoint -> {

                // shows main connect info
                log.info("MQTT client [" + endpoint.clientIdentifier() + "] request to connect, clean session = " + endpoint.isCleanSession());

                if (endpoint.auth() != null) {
                    log.info("[username = " + endpoint.auth().userName() + ", password = " + endpoint.auth().password() + "]");
                }
                if (endpoint.will() != null) {
                    log.info("[will topic = " + endpoint.will().willTopic() + " msg = " + endpoint.will().willMessage() +
                            " QoS = " + endpoint.will().willQos() + " isRetain = " + endpoint.will().isWillRetain() + "]");
                }

                log.info("[keep alive timeout = " + endpoint.keepAliveTimeSeconds() + "]");

                // accept connection from the remote client
                endpoint.writeConnack(MqttConnectReturnCode.CONNECTION_ACCEPTED, false);

          })
          .listen(ar -> {

              if (ar.succeeded()) {

                  log.info("MQTT server is listening on port " + ar.result().actualPort());
              } else {

                  log.info("Error on starting the server");
                  ar.cause().printStackTrace();
              }
          });
----
