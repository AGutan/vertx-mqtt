= Vert.x MQTT server

This component provides a server which is able to handle connections, communication and messages exchange with remote [MQTT](http://mqtt.org/) clients. Its API provides a bunch of events related to raw protocol messages received by clients and exposes some functionalities in order to send messages to them.

It's not a fully featured MQTT broker but can be used for building something like that or for protocol translation (MQTT <--> ?).

WARNING: this module has the tech preview status, this means the API can change between versions.

== Using Vert.x MQTT server

As component not yet officially released in the Vert.x stack, to use the Vert.x MQTT server current snapshot version, add the following repository under the _repositories_ section and the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<repository>
  <id>oss.sonatype.org-snapshot</id>
  <url>https://oss.sonatype.org/content/repositories/snapshots</url>
</repository>
----

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-mqtt-server</artifactId>
  <version>3.4.0-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
compile io.vertx:vertx-mqtt-server:3.4.0-SNAPSHOT
----

[source,groovy,subs="+attributes"]
----
maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
----

== Getting Started

=== Handling client connection/disconnection

This example shows how it's possible to handle the connection request from a remote MQTT client. First, an *_MqttServer_* instance is created and the _endpointHandler_ method is used to specify the handler called when a remote client sends a CONNECT message for connecting to the server itself. The *_MqttEndpoint_* instance, provided as parameter to the handler, brings all main information related to the CONNECT message like client identifier, username/password, "will" information, clean session flag, protocol version and the "keep alive" timeout. Inside that handler, the _endpoint_ instance provides the _writeConnack_ method for replying to the remote client with the corresponding CONNACK message : in this way, the connection is established. Finally, the server is started using the _listen_ method with the default behavior (on localhost and default MQTT port 1883). The same method allows to specify an handler in order to check if the server is started properly or not.

[source,java]
----
MqttServer mqttServer = MqttServer.create(vertx);
mqttServer.endpointHandler(endpoint -> {

                // shows main connect info
                log.info("MQTT client [" + endpoint.clientIdentifier() + "] request to connect, clean session = " + endpoint.isCleanSession());

                if (endpoint.auth() != null) {
                    log.info("[username = " + endpoint.auth().userName() + ", password = " + endpoint.auth().password() + "]");
                }
                if (endpoint.will() != null) {
                    log.info("[will topic = " + endpoint.will().willTopic() + " msg = " + endpoint.will().willMessage() +
                            " QoS = " + endpoint.will().willQos() + " isRetain = " + endpoint.will().isWillRetain() + "]");
                }

                log.info("[keep alive timeout = " + endpoint.keepAliveTimeSeconds() + "]");

                // accept connection from the remote client
                endpoint.writeConnack(MqttConnectReturnCode.CONNECTION_ACCEPTED, false);

          })
          .listen(ar -> {

              if (ar.succeeded()) {

                  log.info("MQTT server is listening on port " + ar.result().actualPort());
              } else {

                  log.info("Error on starting the server");
                  ar.cause().printStackTrace();
              }
          });
----

The same _endpoint_ instance provides the _disconnectHandler_ for specifying the handler called when the remote client sends a DISCONNECT message in order to disconnect from the server; this handler takes no parameters.

[source,java]
----
// handling disconnect message
endpoint.disconnectHandler(v -> {

    log.info("Received disconnect from client");
});
----

=== Handling client subscription/unsubscription request

After a connection is established between client and server, the client can send a subscription request for a topic using the SUBSCRIBE message. The *_MqttEndpoint_* class allows to specify an handler for the incoming subscription request using the _subscribeHandler_ method. Such handler receives an instance of the *_MqttSubscribeMessage_* class which brings the list of topics with related QoS levels as desired by the client. Finally, the endpoint instance provides the _writeSuback_ method for replying to the client with the related SUBACK message containing the granted QoS levels.

[source,java]
----
// handling requests for subscriptions
endpoint.subscribeHandler(subscribe -> {

    List<Integer> grantedQosLevels = new ArrayList<>();
    for (MqttTopicSubscription s: subscribe.topicSubscriptions()) {
        log.info("Subscription for " + s.topicName() + " with QoS " + s.qualityOfService());
        grantedQosLevels.add(s.qualityOfService().value());
    }
    // ack the subscriptions request
    endpoint.writeSuback(subscribe.messageId(), grantedQosLevels);

});
----

In the same way, it's possible to use the _unsubscribeHandler_ method on the endpoint in order to specify the handler called when the client sends an UNSUBSCRIBE message. This handler receives an instance of the *_MqttUnsubscribeMessage_* class as parameter with the list of topics to unsubscribe. Finally, the endpoint instance provides the _writeUnsuback_ method for replying to the client with the related UNSUBACK message.

[source,java]
----
// handling requests for unsubscriptions
endpoint.unsubscribeHandler(unsubscribe -> {

    for (String t: unsubscribe.topics()) {
      log.info("Unsubscription for " + t);
    }
    // ack the subscriptions request
    endpoint.writeUnsuback(unsubscribe.messageId());
});
----

=== Handling client published message

In order to handle incoming messages published by the remote client, the *_MqttEndpoint_* class provides the _publishHandler_ method for specifying the handler called when the client sends a PUBLISH message. This handler receives an instance of the *_MqttPublishMessage_* class as parameter with the payload, the QoS level, the duplicate and retain flags.

If the QoS level is 0 (AT_MOST_ONCE), there is no need from the endpoint to reply the client.

If the QoS level is 1 (AT_LEAST_ONCE), the endpoind needs to reply with a PUBACK message using the available _writePuback_ method.

If the QoS level is 2 (EXACTLY_ONCE), the endpoint needs to reply with a PUBREC message using the available _writePubrec_ method; in this case the same endpoint should handle the PUBREL message received from the client as well (the remote client sends it after receiving the PUBREC from the endpoint) and it can do that specifying the handler through the _pubrelHandler_ method. In order to close the QoS level 2 delivery, the endpoint can use the _writePubcomp_ method for sending the PUBCOMP message to the client.

[source,java]
----
// handling incoming published messages
endpoint.publishHandler(message -> {

    log.info("Just received message [" + message.payload().toString(Charset.defaultCharset()) + "] with QoS [" + message.qosLevel() + "]");

    if (message.qosLevel() == MqttQoS.AT_LEAST_ONCE) {
        endpoint.writePuback(message.messageId());
    } else if (message.qosLevel() == MqttQoS.EXACTLY_ONCE) {
        endpoint.writePubrec(message.messageId());
    }

}).pubrelHandler(messageId -> {

    endpoint.writePubcomp(messageId);
});
----

=== Publish message to the client

The endpoint can publish a message to the remote client (sending a PUBLISH message) using the _writePublish_ method which takes the following input parameters : the topic to publish, the payload, the QoS level, the duplicate and retain flags.

If the QoS level is 0 (AT_MOST_ONCE), the endpoint won't receiving any feedback from the client.

If the QoS level is 1 (AT_LEAST_ONCE), the endpoint needs to handle the PUBACK message received from the client in order to receive final acknowledge of delivery. It's possible using the _pubackHandler_ method specifying such an handler.

If the QoS level is 2 (EXACTLY_ONCE), the endpoint needs to handle the PUBREC message received from the client. The _pubrecHandler_ method allows to specify the handler for that. Inside that handler, the endpoint can use the _writePubrel_ method for replying to the client with the PUBREL message. The last step is to handle the PUBCOMP message received from the client as final acknowledge for the published message; it's possible using the _pubcompHandler_ for specifying the handler called when the final PUBCOMP message is received.

[source,java]
----
// just as example, publish a message with QoS level 2
endpoint.writePublish("my_topic",
        Buffer.buffer("Hello from the Vert.x MQTT server"),
        MqttQoS.EXACTLY_ONCE,
        false,
        false);

// specifing handlers for handling QoS 1 and 2
endpoint.pubackHandler(messageId -> {

  log.info("Received ack for message = " +  messageId);

}).pubrecHandler(messageId -> {

  endpoint.writePubrel(messageId);

}).pubcompHandler(messageId -> {

  log.info("Received ack for message = " +  messageId);
});
----
